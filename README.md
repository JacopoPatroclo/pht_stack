![logo](/public/logo.svg)

# PHT Stack

P stands for Postgres, H stands for HTMX, and T stands for Typescript. Fastify is hidden but is there. This is a stack for developing fast web applications.
You can write your template with JSX to have a composable and type-safe way to write your views.

## Why

If you want to develop a server side first application with Node.js you have a lot of options today. But I feel that server fist approches in this world of spa vs rsc is a little bit "put aside". This has lead to, in my opinion, poor design choiches designing those frameworks. Let's see some of the concerns with the current state of things and how this stack tries to solve them.

### Template enginges

We still don't have a well integrated template engine with Typescript. We have some options like EJS, Pug, and others, but they are not type-safe and the composition apis that they offer is sometimes cumbersome and prone to errors. Fortunately, we have JSX, a well known and type-safe way to write views. We choose to use @kitajs/html as a jsx library because it is fast and handle suspense and error boundaries.

### Request validation

If we want to go with something like Astro or Next.js, the http server exposed by both is not going to help you with request validation, serialization, http verb segregation (if you want to have a POST /path and a GET /path you have to use if statements) and other things that are common in a server side application. We choose Fastify because it is fast, handles serialization and request validation out of the box and has a good plugin system. The only downside to Fastify is the fact that there is no good starter template for developing server first web applications. This repository is a try to solve this problem.

### Who needs file routing?

I don't like the file routing system that Next.js and other frameworks use. I think that it is a little bit cumbersome to use and it is really hard to do it in a typesafe way. Morehover I don't want to have to name my files following some wierd convention. When you want to search for a file that handles the routing part of your product detail page you are goint to search for something like `product` or `detail`, you are not going to search for `[...slug].tsx`.

### Database

I think that Drizzle in combination with Drizzle-kit is the best ORM currently available for Typescript. I have nothing more to say.

## Getting started

You can clone this repo and run the following

```sh
rm -rf .git
git init
pnpm install
pnpm gen-session-key
pnpm dev
```

and you should have a running server at `http://localhost:3000` serving some html.

## Project Structure

- `src` contains the source code for the server
  - `components` contains the components that are used globally
  - `database` contains the database connection and the drizzle tables definitions
  - `plugins` contains the plugins that are used globally (registered automatically)
  - `modules` contains the modules that will contain all the business logic of your application. Every file in this directory that ends with `.routes.tsx` or `.routes.ts` will be registered automatically.
  - `env.ts` validate and expose environment variables
  - `app.ts` is the file that creates the server (see builder pattern in Fastify documentation)
  - `index.ts` is the entry point of the server
  - `main.css` is the main CSS file used by Tailwind CSS
- `client` contains the client code, each TypeScript file in this directory will be used as an entry point for the client scripts. The output will be placed in the `public/dist` directory.
- `public` contains the public files that are served by the server
- `migrations` contains the database migrations generated by Drizzle
- `tsconfig.app.json` is the TypeScript configuration file for the server
- `tsconfig.client.json` is the TypeScript configuration file for the client
- `tsconfig.json` is the base typescript configuration file
- `tsconfig.test.json` is the TypeScript configuration file for transpiling for the tests
- `drizzle.cofig.ts` the configuration file for Drizzle
- `cypress.config.ts` the configuration file for Cypress
- `cypress` contains the end-to-end tests
  - `e2w` contains the end-to-end tests files
  - `support` contains the support files for the end-to-end tests, like commands and custom assertions
  - `fixtures` contains the fixtures used by the end-to-end tests
- `scripts` contains the scripts used by the project
  - `e2e.mjs` the script to orchestrated the end-to-end tests run by Cypress, you should use this on CI. Locally you can use the Cypress GUI
  - `build.mjs` a small script to orchestrate the build process, it handles the client and server builds, Tailwind CSS, the node dev server, and the Docker Compose up command
  - `session-key.mjs` script to generate a secure session key, it is going to insert the key into the .env.local file. If you want to generate it into another file, you can pass the file path as an argument ex: `pnpm gen-session-key .env`

## Technologies

This project uses the following technologies:

- [Fastify](https://fastify.io)
- [Drizzle](https://orm.drizzle.team)
- [HTMX](https://htmx.org/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Postgres](https://www.postgresql.org/)
- [Typescript](https://www.typescriptlang.org)
- [Esbuild](https://esbuild.github.io/)
- [Node.js](https://nodejs.org)
- [Cypress](https://www.cypress.io/)
- [@kitajs/html](https://github.com/kitajs/html)

Make sure to check the documentation of each technology to understand how to use them.

## Development

This project uses `pnpm` as the package manager. To install the dependencies, run `pnpm install`.
To start the development server, run

```sh
pnpm dev
```

To run the unit tests, run

```sh
pnpm test
```

To build for production, run

```sh
pnpm build
```

To run the type check and lint, run

```sh
pnpm typecheck
pnpm lint
```

There is a check command to run various check commands at once.
See package.json for more details.

```sh
pnpm check
```

To run the end-to-end tests, run

```sh
pnpm e2e
```

## Deployment

This section varies depending on the deployment platform. There is a Dockerfile that you can use to create a container. The container will serve the application on port 3000. You can build it like this:

```sh
docker build -t pht-stack .
```

After that, you can push that container to a container registry and deploy it to your platform of choice.

## E2E Tests

This project uses Cypress for end-to-end tests. Locally, while developing your app you should start the dev serve into one terminal and run the Cypress GUI in another terminal. To do that, run:

```sh
pnpm dev
```

```sh
pnpm cypress open
```

This will open the Cypress GUI where you can run the tests. You can also run the tests in headless mode by running:

```sh
pnpm e2e
```

## Use Alpine.js

You can easily use Alpine.js in your project. Just install it with

```sh
pnpm install alpinejs
```

Then you can edit like so the `client/main.ts` file

```ts
import Alpine from 'alpinejs';
import htmx from 'htmx.org';

window.htmx = htmx;
window.Alpine = Alpine;

Alpine.start();

declare global {
  interface Window {
    htmx: typeof htmx;
    Alpine: typeof Alpine;
  }
}

// ...rest of the file
```

## Use another database

To use another database, you need to go into the package.json and remove the current driver dependencies, installing the one that you want to use with Drizzle. Afterward, you need to update the [database.ts file](src/database/database.ts) with the new way of creating the SQL client (changing the content of the function `makeSqlClient`). The last thing you need to do is to update the [Drizzle config file](drizzle.config.ts) with the new driver and connection parameters if needed.

## Use Preact or other jsx libraries for the frontend

You can configure the client to use Preact or other jsx libraries by changing the `jsx`, `jsxFactory` and `jsxFragmentFactory` in the `tsconfig.client.json` file. Then you need to install the library that you want to use, for example

```sh
pnpm install preact
```

After that you just create a new entrypoint file inside the `client` directory and you are good to go. You can now in your html import the script from `public/dist`. Remember to add also an element where the app will be mounted.

## Contributing

If you like to change some default behaviour or setup for this starter, feel free to open an issue or a pull request. I will be happy to help you. Make sure that you add some kind of explanation about the changes that you are proposing. So that we can have a miningful discussion about it.
